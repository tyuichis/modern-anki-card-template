<!-- modern-anki-card-template
Copyright (C) 2025 Tommy Yuichi Siek

This file is part of modern-anki-card-template.
Licensed under the AGPL-3.0 License.
See the LICENSE file in the project root for details. -->

<!-- 
    Highlight.js v11.9.0 (git: b7ec4bfafc)
    (c) 2006-2023 undefined and other contributors
    License: BSD-3-Clause
-->

<!-- Some icons used are from Framework7 - Licensed under MIT -->

<link rel="stylesheet" href="_github-dark.min.css" />

<script>
  // Check if it's a mobile user agent or Android (outside the function)

  var isMobile;
  if (!isMobile) {
    isMobile =
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent,
      );
  }

  // DOM Cache (initialize as null, will be assigned after the DOM is loaded)
  var subjectElement = null;
  var subjectCategory = null;
  var matchedCategoryColor;

  /* cache JS api items */
  var remainingCards = null;

  /* cache status bar items (undo, flag buttons) */

  var undoButton = null;
  var flagButton = null;
  var flag = null;
  var flagId = null;

  if (!globalThis.labelColors) {
    globalThis.labelColors = {
      yellow: {
        dark: {
          fontColor: '#ffc533',
          backgroundColor: 'rgba(255,197,51,0.15)',
        },
        light: {
          fontColor: '#b28b20',
          backgroundColor: 'rgba(255,221,112,0.2)',
        },
      },
      red: {
        dark: { fontColor: '#ff6161', backgroundColor: 'rgba(255,97,97,0.15)' },
        light: {
          fontColor: '#b24c4c',
          backgroundColor: 'rgba(255,153,153,0.2)',
        },
      },
      blue: {
        dark: {
          fontColor: '#57c1ff',
          backgroundColor: 'rgba(87,193,255,0.15)',
        },
        light: {
          fontColor: '#2d72d9',
          backgroundColor: 'rgba(173,216,230,0.2)',
        },
      },
      green: {
        dark: {
          fontColor: '#59d499',
          backgroundColor: 'rgba(89,212,153,0.15)',
        },
        light: {
          fontColor: '#3a805a',
          backgroundColor: 'rgba(144,238,144,0.2)',
        },
      },
      orange: {
        dark: {
          fontColor: '#ff9f0b',
          backgroundColor: 'rgba(255,159,11,0.15)',
        },
        light: {
          fontColor: '#b25f1e',
          backgroundColor: 'rgba(255,200,130,0.2)',
        },
      },
      pink: {
        dark: {
          fontColor: '#ff86b5',
          backgroundColor: 'rgba(255,134,181,0.15)',
        },
        light: {
          fontColor: '#b24863',
          backgroundColor: 'rgba(255,182,193,0.2)',
        },
      },
      turquoise: {
        dark: {
          fontColor: '#40e0d0',
          backgroundColor: 'rgba(64,224,208,0.15)',
        },
        light: {
          fontColor: '#2a716b',
          backgroundColor: 'rgba(176,224,230,0.2)',
        },
      },
      purple: {
        dark: {
          fontColor: '#b19cd9',
          backgroundColor: 'rgba(177,156,217,0.15)',
        },
        light: {
          fontColor: '#6b42c7',
          backgroundColor: 'rgba(216,191,216,0.2)',
        },
      },
      default: {
        dark: {
          fontColor: '#cccccc',
          backgroundColor: 'rgba(60, 60, 60, 0.5)',
        },
        light: {
          fontColor: '#444444',
          backgroundColor: 'rgba(220, 220, 220, 0.4)',
        },
      },
    };
  }

  /* flag logic */

  if (!globalThis.FLAG_COLORS) {
    globalThis.FLAG_COLORS = {
      // colorName: flagId
      red: 1,
      orange: 2,
      green: 3,
      blue: 4,
      pink: 5,
      turquoise: 6,
      purple: 7,
    };
  }

  function getFlagId(subjectColor) {
    try {
      const flagId = FLAG_COLORS?.[subjectColor] ?? 0; // i.e. FLAG_COLORS["red"] => 1
      return flagId;
    } catch (error) {
      console.error('Error retrieving flag ID:', error); // More specific message
      return 0; // Return default value on error.  0 makes more sense than null here.
    }
  }

  // Function to update CSS classes on the flag button
  function setFlagDisplay(flagId) {
    const flagButton = document.getElementById('flag-button'); // caching

    if (!flagButton) {
      console.warn('Flag button element not found.');
      return;
    }

    const flagColor =
      Object.entries(FLAG_COLORS).find(([color, id]) => id === flagId)?.[0] ||
      null;

    // Reset: Remove all flag color classes
    for (const color of [
      'red',
      'orange',
      'green',
      'blue',
      'pink',
      'turquoise',
      'purple',
    ]) {
      flagButton.classList.remove(`flag-${color}`);
    }

    // Add the appropriate flag color class
    if (flagColor) {
      // Check that flagColor isn't null
      flagButton.classList.add(`flag-${flagColor}`);
    }

    // Toggle the "flagged" class based on whether it's flagged or not
    if (flagId === 0) {
      flagButton.classList.remove('flagged');
    } else {
      flagButton.classList.add('flagged');
    }
  }

  // Update the flag color on page load, depending on its status.
  async function updateFlag() {
    try {
      const flagNumber = await new Promise((resolve) =>
        pycmd('get_flag_status', resolve),
      );

      // Validate the flagNumber
      if (
        typeof flagNumber === 'number' &&
        flagNumber >= 0 &&
        flagNumber <= 7
      ) {
        setFlagDisplay(flagNumber);
      } else {
        console.error(`Invalid flag number received: ${flagNumber}`);
        setFlagDisplay(0); // Set to the default unflagged state
      }
    } catch (e) {
      console.error('Error getting flag status:', e);
      setFlagDisplay(0); // Default to unflagged on error
    }
  }

  // Function to update CSS variables based on subject category
  function updateLabelColors(subjectCategory) {
    let theme = document.body.classList.contains('nightMode')
      ? 'dark'
      : 'light';
    let colorDetails = labelColors[subjectCategory]?.[theme];

    if (colorDetails) {
      document.documentElement.style.setProperty(
        '--label-font-color',
        colorDetails.fontColor,
      );
      document.documentElement.style.setProperty(
        '--label-background-color',
        colorDetails.backgroundColor,
      );
    } else {
      // Set defaults
      document.documentElement.style.setProperty(
        '--label-font-color',
        theme === 'dark' ? '#8E8E93' : '#555',
      );
      document.documentElement.style.setProperty(
        '--label-background-color',
        theme === 'dark' ? 'rgba(44, 44, 46, 0.9)' : 'rgba(200, 200, 200, 0.2)',
      );
      console.error(
        `Color details not found for the subject category: ${subjectCategory}`,
      );
    }
  }

  // Function to get the subject category from the DOM
  function getSubjectFromDOM() {
    subjectElement = document.getElementById('subject');
    if (subjectElement) {
      return subjectElement.textContent.trim().toLowerCase(); // Get subject and make it lowercase to match the subjects object
    } else {
      console.error('Subject element not found.');
      return null;
    }
  }

  // API Setup (mobile only)

  /* disabled for now, until officially supported on Android, and AnkiMobile is supported */
  // var api;
  // if (isMobile) {
  //   var jsApiContract = {
  //     version: '0.0.3',
  //     developer: 'your-email@example.com' /* your email here */,
  //   };
  //   api = new AnkiDroidJS(jsApiContract);
  // }

  // async function ankiCall(method, apiFallback = false) {
  //   if (isMobile && !apiFallback) {
  //     const response = await api[method]();
  //     if (response && response.success) {
  //       return response.value;
  //     } else {
  //       if (response && response.error) {
  //         throw new Error(
  //           `AnkiDroid API call ${method} failed. Error: ${response.error}`,
  //         );
  //       } else {
  //         throw new Error(`AnkiDroid API call ${method} failed.`);
  //       }
  //     }
  //   } else {
  //     const response = await new Promise((resolve) =>
  //       pycmd(`AnkiJS.${method}()`, resolve),
  //     );

  //     // Handle NaN and other cases if needed
  //     const number = isNaN(Number(response)) ? 0 : Number(response);
  //     return number;
  //   }
  // }

  async function ankiCall(method) {
    const response = await new Promise((resolve) =>
      pycmd(`AnkiJS.${method}()`, resolve),
    );

    // Handle NaN and other cases if needed
    const number = isNaN(Number(response)) ? 0 : Number(response);
    return number;
  }

  async function fetchCardCount() {
    var newCards = 0;
    var learningCards = 0;
    var reviewCards = 0;

    try {
      newCards = await ankiCall('ankiGetNewCardCount');
      learningCards = await ankiCall('ankiGetLrnCardCount');
      reviewCards = await ankiCall('ankiGetRevCardCount');

      // console.log(
      //   'API Results - New:',
      //   newCards,
      //   ' Learning:',
      //   learningCards,
      //   ' Review:',
      //   reviewCards,
      // );
    } catch (e) {
      console.error('Error fetching card counts:', e);
    }

    return { new: newCards, learn: learningCards, review: reviewCards };
  }

  function updateRemainingCards(remainingCardCount) {
    remainingCards = document.querySelector('#remainingCards');
    if (remainingCards) {
      remainingCards.textContent = remainingCardCount;
    } else {
      console.warn('Element #remainingCards not found in the DOM.');
    }
  }
</script>

<!-- Front Side -->

<section id="main">
  <div id="status-bar">
    <ul id="status-bar-buttons">
      <!-- Undo Button -->
      <li>
        <div id="undo-button" class="button">
          <span id="undo-icon">
            <svg
              width="16"
              height="16"
              viewBox="0 0 16 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1.51562 7.00022H1.25C0.834375 7.00022 0.5 6.66585 0.5 6.25022V2.25022C0.5 1.9471 0.68125 1.6721 0.9625 1.55647C1.24375 1.44085 1.56562 1.50335 1.78125 1.71897L3.08125 3.01897C5.81875 0.315849 10.2281 0.325224 12.95 3.05022C15.6844 5.7846 15.6844 10.2158 12.95 12.9502C10.2156 15.6846 5.78437 15.6846 3.05 12.9502C2.65937 12.5596 2.65937 11.9252 3.05 11.5346C3.44062 11.144 4.075 11.144 4.46562 11.5346C6.41875 13.4877 9.58438 13.4877 11.5375 11.5346C13.4906 9.58147 13.4906 6.41585 11.5375 4.46272C9.59375 2.51897 6.45312 2.5096 4.49687 4.43147L5.78125 5.71897C5.99688 5.9346 6.05937 6.25647 5.94375 6.53772C5.82812 6.81897 5.55312 7.00022 5.25 7.00022H1.51562Z"
                fill="#49A2D5"
              />
            </svg>
          </span>
          <span id="undo">Undo</span>
        </div>
      </li>
      <!-- Flag Button -->
      <li>
        <div id="flag-button" class="button">
          <span id="flag-icon">
            <svg
              width="14"
              height="16"
              viewBox="0 0 14 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M2 1C2 0.446875 1.55313 0 1 0C0.446875 0 0 0.446875 0 1V2V11.5V15C0 15.5531 0.446875 16 1 16C1.55313 16 2 15.5531 2 15V11L4.00937 10.4969C5.29375 10.175 6.65313 10.325 7.8375 10.9156C9.21875 11.6062 10.8219 11.6906 12.2656 11.1469L13.35 10.7406C13.7406 10.5938 14 10.2219 14 9.80313V2.0625C14 1.34375 13.2438 0.875 12.6 1.19687L12.3 1.34687C10.8531 2.07187 9.15 2.07187 7.70312 1.34687C6.60625 0.796875 5.34687 0.659375 4.15625 0.95625L2 1.5V1Z"
                fill="white"
              />
            </svg>
          </span>
          <span id="flag">Flag</span>
        </div>
      </li>
    </ul>
  </div>

  <div id="flashcard-container">
    <div id="flashcard-title">
      <h1 id="title">
        {{^Card Category}}Untitled{{/Card Category}}{{Card Category}}
      </h1>
    </div>
    <div id="flashcard-labels">
      <div id="deck-name-container">
        <span class="deck-icon">
          <svg
            width="56"
            height="56"
            viewBox="0 0 56 56"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill="currentColor"
              d="M12.695 4.656h30.633c-.14-1.968-1.266-3.023-3.422-3.023H16.117c-2.156 0-3.281 1.055-3.422 3.023m-4.594 6.492h39.844c-.351-2.132-1.383-3.304-3.726-3.304H11.805c-2.344 0-3.352 1.172-3.703 3.304m2.133 43.22H45.79c4.875 0 7.336-2.438 7.336-7.266V22.21c0-4.828-2.46-7.266-7.336-7.266H10.234c-4.898 0-7.36 2.414-7.36 7.266V47.1c0 4.829 2.462 7.266 7.36 7.266m.07-3.774c-2.343 0-3.656-1.266-3.656-3.703V22.398c0-2.437 1.313-3.68 3.657-3.68h35.414c2.32 0 3.632 1.243 3.632 3.68v24.493c0 2.437-1.312 3.703-3.632 3.703Z"
            />
          </svg>
        </span>
        <span id="deck-name">{{Subdeck}}</span>
      </div>
      <div id="flashcard-subject">
        <span id="subject" class="subject-label"
          >{{^Subject}}No topic selected{{/Subject}}{{Subject}}</span
        >
      </div>
    </div>
    <div id="flashcard-content">
      <div id="flashcard-textbox">
        <div id="flashcard-question">
          <span id="question-marker"></span>
          <p id="question-text">{{Question}}</p>
        </div>
      </div>
    </div>
    <div id="flashcard-info">
      <div id="flashcard-source-info" class="flashcard-metadata">
        <span id="source-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
            <path
              d="M0 48V487.7C0 501.1 10.9 512 24.3 512c5 0 9.9-1.5 14-4.4L192 400 345.7 507.6c4.1 2.9 9 4.4 14 4.4c13.4 0 24.3-10.9 24.3-24.3V48c0-26.5-21.5-48-48-48H48C21.5 0 0 21.5 0 48z"
            />
          </svg>
        </span>
        <span id="source-text">{{^Source}}{{/Source}}{{Source}}</span>
      </div>
      <div id="deck-remaining-cards-container" class="flashcard-metadata">
        <span class="deck-icon">
          <svg
            width="56"
            height="56"
            viewBox="0 0 56 56"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill="currentColor"
              d="m11.83 46.622l.59-.102v1.159c0 4.187 2.114 6.301 6.382 6.301h30.815c4.25 0 6.383-2.114 6.383-6.301V26.072c0-4.167-2.134-6.281-6.383-6.281h-4.756l-1.2-6.911c-.73-4.127-3.21-5.834-7.378-5.102L5.935 13.144Q-.375 14.24.752 20.462l3.7 21.058c.752 4.126 3.19 5.834 7.378 5.102m-4.187-5.854L4.004 20.055c-.386-2.073.55-3.354 2.541-3.7l30.267-5.345c1.971-.346 3.293.548 3.659 2.622l1.097 6.159H18.802c-4.268 0-6.382 2.093-6.382 6.28v17.116l-1.098.203c-2.012.346-3.313-.549-3.68-2.622m11.2 9.94c-2.033 0-3.15-1.098-3.15-3.212V26.255c0-2.114 1.117-3.192 3.15-3.192h30.734c1.992 0 3.15 1.078 3.15 3.192v21.241c0 2.114-1.158 3.212-3.15 3.212Z"
            />
          </svg>
        </span>
        <span id="deck-count"
          >Cards remaining: <span id="remainingCards">0</span></span
        >
      </div>
    </div>
  </div>
</section>

<script>
  var syntaxHighlighting = false; // Default is off; set to syntaxHighlighting = true; to turn on. Be sure to import _highlight_min.js and the language pack.
  var hljs; // cache hljs
  var loadedLanguages = {}; // cache loaded languages

  async function loadHighlightJS() {
    if (!syntaxHighlighting) {
      return false; // syntaxHighlighting is off. Don't load.
    }

    if (hljs) {
      // console.log('Highlight.js is already loaded.');
      return true; // hljs already loaded
    }

    try {
      // load highlight.js core
      const hljsModule = await import('/_highlight.min.js');
      hljs = hljsModule.default || hljsModule; // cache hljs

      // console.log('Highlight.js loaded:', hljs);

      // languages to load
      const languages = [
        'bash',
        'java',
        'perl',
        'scss',
        'c',
        'javascript',
        'php',
        'shell',
        'cpp',
        'json',
        'python',
        'csharp',
        'kotlin',
        'plaintext',
        'swift',
        'css',
        'less',
        'typescript',
        'diff',
        'lua',
        'vbnet',
        'go',
        'makefile',
        'r',
        'wasm',
        'graphql',
        'markdown',
        'ruby',
        'xml',
        'ini',
        'objectivec',
        'rust',
        'yaml',
      ];

      // load and register languages
      const loadPromises = languages.map(async (lang) => {
        if (loadedLanguages[lang]) {
          // console.log(`Language ${lang} is already loaded.`);
          return; // skip if already loaded
        }

        try {
          const module = await import(`/_${lang}.min.js`);
          hljs.registerLanguage(lang, module.default || module); // register language
          loadedLanguages[lang] = true; // cache loaded language
          // console.log(`Language ${lang} loaded.`);
        } catch (error) {
          // console.warn(`Failed to load language: ${lang}`, error);
        }
      });

      // wait for all languages to load
      await Promise.allSettled(loadPromises);

      // console.log('All languages attempted to load:', languages);

      return true; // all loaded successfully
    } catch (error) {
      // console.error('Failed to load Highlight.js:', error);
      return false; // error loading
    }
  }

  async function applyHighlighting() {
    if (!syntaxHighlighting) {
      return; // syntaxHighlighting is off. Don't run.
    }

    const isLoaded = await loadHighlightJS(); // wait for hljs to load

    if (!isLoaded) {
      console.error('Highlight.js was not loaded successfully.');
      return; // stop if hljs failed to load
    }

    // highlight code blocks
    document.querySelectorAll('pre code').forEach((block) => {
      // console.log('Highlighting block:', block);
      hljs.highlightElement(block); // highlight block
    });

    // highlight inline code
    document.querySelectorAll('code:not(pre code)').forEach((block) => {
      // console.log('Highlighting inline block:', block);
      hljs.highlightElement(block); // highlight inline block
    });

    // console.log('Highlighting applied successfully.');
  }

  // apply highlighting
  applyHighlighting();
</script>

<script>
  // keep track of failed loads for debugging
  if (!globalThis.loadedSubjects) {
    globalThis.loadedSubjects = {};
  }

  var subjectJSON;

  if (!subjectJSON) {
    subjectJSON = [
      'computer-science',
      'languages',
      'chemistry',
      'biology',
      'math',
      'medicine',
      'physics',
      'custom',
    ];
  }

  function getSubjectFromDOM() {
    subjectElement = document.getElementById('subject');
    return subjectElement
      ? subjectElement.textContent.trim().toLowerCase()
      : null;
  }

  function applySubjectStyling() {
    subjectCategory = getSubjectFromDOM();
    if (!subjectCategory) return;

    matchedCategoryColor = globalThis.subjects[subjectCategory] || 'default';
    updateLabelColors(matchedCategoryColor);
    flagId = getFlagId(matchedCategoryColor);
  }

  async function loadAllSubjectJSON() {
    if (globalThis.subjects) return;
    globalThis.subjects = {};
    await Promise.all(
      subjectJSON.map(async (subjectName) => {
        try {
          const response = await fetch(`/_color-preset-${subjectName}.json`);
          if (!response.ok) {
            globalThis.loadedSubjects[subjectName] = false;
            return;
          }

          const data = await response.json();
          Object.assign(globalThis.subjects, data);
          globalThis.loadedSubjects[subjectName] = true;
        } catch (error) {
          console.error(
            `Error loading /_color-preset-${subjectName}.json:`,
            error,
          );
          globalThis.loadedSubjects[subjectName] = false;
        }
      }),
    );
  }

  (async () => {
    if (!globalThis.subjects) {
      await loadAllSubjectJSON();
    }
    applySubjectStyling();
  })();
</script>

<script>
  if (!isMobile) {
    // Fetch and update card counts from API
    fetchCardCount().then((cardCounts) => {
      var totalRemaining =
        cardCounts.new + cardCounts.learn + cardCounts.review;
      updateRemainingCards(totalRemaining);
    });

    /* status buttons */

    undoButton = document.querySelector('#undo-button');

    undoButton.addEventListener('click', () => {
      // console.log('undo_card called');
      pycmd('undo_card');
    });
    // custom flag button only exists on desktop
    updateFlag(); // update on page reload. updates the visual state of the flag.

    // setup event listener
    flagButton = document.getElementById('flag-button');
    flagButton.addEventListener('click', async () => {
      // console.log('set_flag_[flagId] called');
      try {
        const flagStatus = await new Promise((resolve) =>
          pycmd(`set_flag_${flagId}`, resolve),
        );

        updateFlag();
      } catch (e) {
        // console.log('Error getting flag status:', e);
      }
    });
  }
</script>
